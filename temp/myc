#!/bin/sh

te=~/dotfiles/temp/te

get_couple() {
    couple_str=$(grep $bookmark" ## " $te)
    # splits #couple_str by ' ## ' into array
    local IFS=" ## "
    read -ra couple <<< $couple_str
}

ask_replace() {
    while :
    do
        read -p "Would you like to replace this bookmark? (Y/n) :  " answer
        case $answer in
            "Y")
                echo "Overriding old [UNDESERVING] bookmark..."
                return 0
                ;;
            "n")
                echo "Not overriding old [DESERVING] bookmark..."
                return 1
                ;;
        esac
    done
}

m_add () {
    name=$1
    maybe_path=$2
    name_in_file=$(grep $name" ## " $te)

    # Checks if the bookmark name is in bookmark file. If so, ask to override
    if [[ -n "$name_in_file" ]]; then # If length of string is nonzero
        echo "This bookmark name already exists"
        echo "$name_in_file"
        ask_replace
        # $? is exit code for previous function (aka what they return)
        [[ $? = 1 ]] && return 1 # 1 means no, 0 means yes
        m_remove $name
    fi
  
    if [[ -z "$maybe_path" ]]; then # If empty string
        path=$PWD
    else
        temp_path=$PWD"/"$maybe_path # Making the path absolute
        # If path is a legit directory
        if [[ -d "$temp_path" ]]; then
            path=$temp_path
        elif [[ -d "$maybe_path" ]]; then # it's already an absolute file path
            path=$maybe_path
        else
            echo "$maybe_path"" does not exist or is not a directory."
            return 1
        fi
    fi
    
    # Checks if the path is in bookmark file. If so, ask to override
    # path_in_file=$(grep " ## ""$path"$  $te) # $ indicates EOL
    # if [[ -n "$path_in_file" ]]; then # If length of string is nonzero
    #     echo "This path has already been bookmarked"
    #     echo $path_in_file
    #     ask_replace
    #     # $? is the exit code of the last function called
    #     [[ $? = 1 ]] && return 1 # 1 means no, 0 means yes
    #     m_remove $path
    # fi

    echo $path" is now bookmarked to "$name
    echo $name" ## "$path >> $te
    return 0
}

m_remove() {
    # Notes: ^ indicates beginning of line
    #        $ indicates end of line
    rem_this=$1
    echo "You are removing this bookmark: $rem_this..."
    if [[ -n $(grep ^"$rem_this"" ## " $te) ]]; then # it is a bookmark name
        sed -i "/^$rem_this ## /d" $te
    elif [[ -n $(grep " ## ""$rem_this"$ $te) ]]; then # it is a file path
        echo "You are removing this bookmark: $rem_this"
        sed -i "/ ## $rem_this$/d" $te
    else
        echo "$rem_this was not found in $te"
    fi
}

go_to() {
    bookmark=$1
    # EXAMPLE: couple_str = "bookmark_name ## /path/to/book/mark"
    couple_str=$(grep ^"$bookmark"" ## " $te)
 
    # splits #couple_str by ' ## ' into array
    local IFS=" ## "
    read -ra couple <<< $couple_str
    go_path="${couple[1]}"
    if [[ -d $go_path ]]; then # If path is a legit directory
        cd "$go_path"
    else
        echo $go_path" does not exist."
    fi
}

list_all() {
    if [[ "$1" = "-s" ]]; then
        cat $te | sort
    else
        cat $te
    fi
}

myc() {
    case $1 in
        "-h")
            echo 'myc [bookmark_name] [path (or empty for cwd)]'
            ;;
        "add")
            echo "gonna add something soon probably" >> .myc
            m_add $2 $3
            ;;
        "rm")
            m_remove $2
            ;;
        "l")
            echo "Bookmarks:"
            list_all $2
            ;;
        "")
            echo "got string?"
            ;;
        *)
            go_to $1
            ;;
    esac
}


#TODO:
# - change q l to q ls (better to avoid confusion)
# - -l to list directories right after cd-ing there
# - -f to find the path that a bookmark refers to
# - -v to open vim on the path that a bookmark refers to
# - -cv to change directory to the path and also open vim
# - tab completion!
# - have a thing to make the bookmark file
# getopts!
# rename to QUIRK!

